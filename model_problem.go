/*
Tweets and Users

API Reference â€” Labs v2

API version: 2.13
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package twitterapi

import (
	"encoding/json"
	"fmt"
)

// Problem - An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
type Problem struct {
	ClientForbiddenProblem *ClientForbiddenProblem
	DisallowedResourceProblem *DisallowedResourceProblem
	GenericProblem *GenericProblem
	InvalidRequestProblem *InvalidRequestProblem
	ResourceNotFoundProblem *ResourceNotFoundProblem
	ResourceUnauthorizedProblem *ResourceUnauthorizedProblem
	UnsupportedAuthenticationProblem *UnsupportedAuthenticationProblem
	UsageCapExceededProblem *UsageCapExceededProblem
}

// ClientForbiddenProblemAsProblem is a convenience function that returns ClientForbiddenProblem wrapped in Problem
func ClientForbiddenProblemAsProblem(v *ClientForbiddenProblem) Problem {
	return Problem{
		ClientForbiddenProblem: v,
	}
}

// DisallowedResourceProblemAsProblem is a convenience function that returns DisallowedResourceProblem wrapped in Problem
func DisallowedResourceProblemAsProblem(v *DisallowedResourceProblem) Problem {
	return Problem{
		DisallowedResourceProblem: v,
	}
}

// GenericProblemAsProblem is a convenience function that returns GenericProblem wrapped in Problem
func GenericProblemAsProblem(v *GenericProblem) Problem {
	return Problem{
		GenericProblem: v,
	}
}

// InvalidRequestProblemAsProblem is a convenience function that returns InvalidRequestProblem wrapped in Problem
func InvalidRequestProblemAsProblem(v *InvalidRequestProblem) Problem {
	return Problem{
		InvalidRequestProblem: v,
	}
}

// ResourceNotFoundProblemAsProblem is a convenience function that returns ResourceNotFoundProblem wrapped in Problem
func ResourceNotFoundProblemAsProblem(v *ResourceNotFoundProblem) Problem {
	return Problem{
		ResourceNotFoundProblem: v,
	}
}

// ResourceUnauthorizedProblemAsProblem is a convenience function that returns ResourceUnauthorizedProblem wrapped in Problem
func ResourceUnauthorizedProblemAsProblem(v *ResourceUnauthorizedProblem) Problem {
	return Problem{
		ResourceUnauthorizedProblem: v,
	}
}

// UnsupportedAuthenticationProblemAsProblem is a convenience function that returns UnsupportedAuthenticationProblem wrapped in Problem
func UnsupportedAuthenticationProblemAsProblem(v *UnsupportedAuthenticationProblem) Problem {
	return Problem{
		UnsupportedAuthenticationProblem: v,
	}
}

// UsageCapExceededProblemAsProblem is a convenience function that returns UsageCapExceededProblem wrapped in Problem
func UsageCapExceededProblemAsProblem(v *UsageCapExceededProblem) Problem {
	return Problem{
		UsageCapExceededProblem: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *Problem) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into ClientForbiddenProblem
	err = newStrictDecoder(data).Decode(&dst.ClientForbiddenProblem)
	if err == nil {
		jsonClientForbiddenProblem, _ := json.Marshal(dst.ClientForbiddenProblem)
		if string(jsonClientForbiddenProblem) == "{}" { // empty struct
			dst.ClientForbiddenProblem = nil
		} else {
			match++
		}
	} else {
		dst.ClientForbiddenProblem = nil
	}

	// try to unmarshal data into DisallowedResourceProblem
	err = newStrictDecoder(data).Decode(&dst.DisallowedResourceProblem)
	if err == nil {
		jsonDisallowedResourceProblem, _ := json.Marshal(dst.DisallowedResourceProblem)
		if string(jsonDisallowedResourceProblem) == "{}" { // empty struct
			dst.DisallowedResourceProblem = nil
		} else {
			match++
		}
	} else {
		dst.DisallowedResourceProblem = nil
	}

	// try to unmarshal data into GenericProblem
	err = newStrictDecoder(data).Decode(&dst.GenericProblem)
	if err == nil {
		jsonGenericProblem, _ := json.Marshal(dst.GenericProblem)
		if string(jsonGenericProblem) == "{}" { // empty struct
			dst.GenericProblem = nil
		} else {
			match++
		}
	} else {
		dst.GenericProblem = nil
	}

	// try to unmarshal data into InvalidRequestProblem
	err = newStrictDecoder(data).Decode(&dst.InvalidRequestProblem)
	if err == nil {
		jsonInvalidRequestProblem, _ := json.Marshal(dst.InvalidRequestProblem)
		if string(jsonInvalidRequestProblem) == "{}" { // empty struct
			dst.InvalidRequestProblem = nil
		} else {
			match++
		}
	} else {
		dst.InvalidRequestProblem = nil
	}

	// try to unmarshal data into ResourceNotFoundProblem
	err = newStrictDecoder(data).Decode(&dst.ResourceNotFoundProblem)
	if err == nil {
		jsonResourceNotFoundProblem, _ := json.Marshal(dst.ResourceNotFoundProblem)
		if string(jsonResourceNotFoundProblem) == "{}" { // empty struct
			dst.ResourceNotFoundProblem = nil
		} else {
			match++
		}
	} else {
		dst.ResourceNotFoundProblem = nil
	}

	// try to unmarshal data into ResourceUnauthorizedProblem
	err = newStrictDecoder(data).Decode(&dst.ResourceUnauthorizedProblem)
	if err == nil {
		jsonResourceUnauthorizedProblem, _ := json.Marshal(dst.ResourceUnauthorizedProblem)
		if string(jsonResourceUnauthorizedProblem) == "{}" { // empty struct
			dst.ResourceUnauthorizedProblem = nil
		} else {
			match++
		}
	} else {
		dst.ResourceUnauthorizedProblem = nil
	}

	// try to unmarshal data into UnsupportedAuthenticationProblem
	err = newStrictDecoder(data).Decode(&dst.UnsupportedAuthenticationProblem)
	if err == nil {
		jsonUnsupportedAuthenticationProblem, _ := json.Marshal(dst.UnsupportedAuthenticationProblem)
		if string(jsonUnsupportedAuthenticationProblem) == "{}" { // empty struct
			dst.UnsupportedAuthenticationProblem = nil
		} else {
			match++
		}
	} else {
		dst.UnsupportedAuthenticationProblem = nil
	}

	// try to unmarshal data into UsageCapExceededProblem
	err = newStrictDecoder(data).Decode(&dst.UsageCapExceededProblem)
	if err == nil {
		jsonUsageCapExceededProblem, _ := json.Marshal(dst.UsageCapExceededProblem)
		if string(jsonUsageCapExceededProblem) == "{}" { // empty struct
			dst.UsageCapExceededProblem = nil
		} else {
			match++
		}
	} else {
		dst.UsageCapExceededProblem = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.ClientForbiddenProblem = nil
		dst.DisallowedResourceProblem = nil
		dst.GenericProblem = nil
		dst.InvalidRequestProblem = nil
		dst.ResourceNotFoundProblem = nil
		dst.ResourceUnauthorizedProblem = nil
		dst.UnsupportedAuthenticationProblem = nil
		dst.UsageCapExceededProblem = nil

		return fmt.Errorf("Data matches more than one schema in oneOf(Problem)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("Data failed to match schemas in oneOf(Problem)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src Problem) MarshalJSON() ([]byte, error) {
	if src.ClientForbiddenProblem != nil {
		return json.Marshal(&src.ClientForbiddenProblem)
	}

	if src.DisallowedResourceProblem != nil {
		return json.Marshal(&src.DisallowedResourceProblem)
	}

	if src.GenericProblem != nil {
		return json.Marshal(&src.GenericProblem)
	}

	if src.InvalidRequestProblem != nil {
		return json.Marshal(&src.InvalidRequestProblem)
	}

	if src.ResourceNotFoundProblem != nil {
		return json.Marshal(&src.ResourceNotFoundProblem)
	}

	if src.ResourceUnauthorizedProblem != nil {
		return json.Marshal(&src.ResourceUnauthorizedProblem)
	}

	if src.UnsupportedAuthenticationProblem != nil {
		return json.Marshal(&src.UnsupportedAuthenticationProblem)
	}

	if src.UsageCapExceededProblem != nil {
		return json.Marshal(&src.UsageCapExceededProblem)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *Problem) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.ClientForbiddenProblem != nil {
		return obj.ClientForbiddenProblem
	}

	if obj.DisallowedResourceProblem != nil {
		return obj.DisallowedResourceProblem
	}

	if obj.GenericProblem != nil {
		return obj.GenericProblem
	}

	if obj.InvalidRequestProblem != nil {
		return obj.InvalidRequestProblem
	}

	if obj.ResourceNotFoundProblem != nil {
		return obj.ResourceNotFoundProblem
	}

	if obj.ResourceUnauthorizedProblem != nil {
		return obj.ResourceUnauthorizedProblem
	}

	if obj.UnsupportedAuthenticationProblem != nil {
		return obj.UnsupportedAuthenticationProblem
	}

	if obj.UsageCapExceededProblem != nil {
		return obj.UsageCapExceededProblem
	}

	// all schemas are nil
	return nil
}

type NullableProblem struct {
	value *Problem
	isSet bool
}

func (v NullableProblem) Get() *Problem {
	return v.value
}

func (v *NullableProblem) Set(val *Problem) {
	v.value = val
	v.isSet = true
}

func (v NullableProblem) IsSet() bool {
	return v.isSet
}

func (v *NullableProblem) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableProblem(val *Problem) *NullableProblem {
	return &NullableProblem{value: val, isSet: true}
}

func (v NullableProblem) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableProblem) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


